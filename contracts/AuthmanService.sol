pragma solidity ^0.4.6;

import "./AuthmanDao.sol";
import "./helper/strings.sol";
import "./helper/myString.sol";
import "./helper/validator.sol";

contract AuthmanService {

  using strings for *;

  AuthmanDao dao;

  function AuthmanService(address authmanCrudAddress) public {
    dao = AuthmanDao(authmanCrudAddress);
  }

  // Used for error handling.
  event AnyException(string message);

  function createOrUpdateAuthman(
    address _address,
    string firstName, 
    string lastName, 
    string ssn,
    string dob, //YYYY-MM-DD
    string pin, //4 digit
    string mobilePhone //10 digit
    ) 
  public returns (uint index)
  {

    //validate ssn
    if (!validator.validateSsn(ssn)) {
      AnyException("SSN is not valid.");
      revert();
    }

    //validate dob YYYY-MM-DD
    if (!validator.validateDob(dob)) {
      AnyException("Date of birth is not valid. Should be of the format YYYY-MM-DD");
      revert();
    }

    //validate pin 4 digits [0-9]{4}
    if (!validator.validatePin(pin)) {
      AnyException("Pin is not valid. Should be 4 digits.");
      revert();
    }

    //if mobile phone exists, validate phone 10 digits [1-9][0-9]{9}
    if (bytes(mobilePhone).length > 0 && !validator.validatePhone(mobilePhone)) {
      AnyException("Mobile phone is not valid. Should be 10 digits with no other characters.");
      revert();
    }

    //evaluate sshHash and check if exists
    var hash = createSsnHash(ssn, dob);

    address savedAddress = dao.getAuthmanAddressBySsnHash(hash);

    bytes32 claimHash = createClaimHash(savedAddress, pin);

    //if authman exists for the ssn hash
    if (dao.getSsnHashByAddress(savedAddress)[0] != 0) {

     //make sure the supplied address is the same as saved address
     if (_address != savedAddress) {
      AnyException("Another address exists for the individual.");
      revert();
    }

    //authman exists, check if claimed
    //if claimed, throw error
    if (dao.getIsClaimedByAddress(savedAddress)) {
     AnyException("Authman is claimed. Cannot update Authman.");
     revert();
   }

   //if not claimed, update Authman
   dao.logAuthman("Authman exists but is not claimed. Updating authman.... Current authman: ", savedAddress);

   return dao.updateAuthman(savedAddress, firstName, lastName, mobilePhone, claimHash, tx.origin);

   } else {

     return dao.createAuthman(_address, firstName, lastName, mobilePhone, tx.origin, hash, claimHash);
   }

 }

 //mobile phone is optional as banks may not have this information for current customers
 function createOrUpdateAuthman(
   address _address,
   string firstName, 
   string lastName, 
   string ssn,
   string dob, //YYYY-MM-DD
   string pin //4 digit (auto generated by banks, when customer is not present)
   ) 
 public returns (uint index)
 {

   return createOrUpdateAuthman(
    _address,
    firstName, 
    lastName, 
    ssn, 
    dob, 
    pin, 
    "" //no mobile phone
    );
 }

 function createSsnHash(string ssn, string dob) constant private returns (bytes32) {

  //split ssn into 3 parts of 3 chars
  string [] memory ssnArr = new string[](3);
  ssnArr[0] = myString.substring(ssn, 0, 3);
  ssnArr[1] = myString.substring(ssn, 3, 6);
  ssnArr[2] = myString.substring(ssn, 6, 9);

  //split dob by dashes
  var dobSlice = dob.toSlice();
  var delim = "-".toSlice();
  string memory year = dobSlice.split(delim).toString();
  string memory  month = dobSlice.split(delim).toString();
  string memory  day = dobSlice.split(delim).toString();

  string memory pipe = "|";
  string memory tilde = "~";

  //concat them like YYYY|S1~MM|S2~DD|N3
  string memory untilMonth = myString.strConcat(year, pipe, ssnArr[0], tilde, month);
  string memory untilDay = myString.strConcat(untilMonth, pipe, ssnArr[1], day);
  string memory hash = myString.strConcat(untilDay, pipe, ssnArr[2]);

  //SSN+DOB keccak256
  return keccak256(hash);

}

function getAddress(string ssn, string dob) constant public returns (address) {

  //validate ssn
  if (!validator.validateSsn(ssn)) {

    AnyException("SSN is not valid.");
    revert();
  }
  //validate dob YYYY-MM-DD
  if (!validator.validateDob(dob)) {

    AnyException("Date of birth is not valid. Should be of the format YYYY-MM-DD");
    revert();
  }

  //evaluate sshHash and check if exists
  var hash = createSsnHash(ssn, dob);
  return dao.getAuthmanAddressBySsnHash(hash);
}

function createClaimHash(address _address, string pin) constant private returns (bytes32) {
  return keccak256(myString.strConcat(myString.addressToString(_address), pin));
}

//claiming authman from phone
function claimAuthmanId(
  string authmanId,
  string mobilePhone, 
  string pin, 
  bytes32 claimHash) public {

  //validate phone 10 digits [1-9][0-9]{9}
  if (!validator.validatePhone(mobilePhone)) {
    AnyException("Mobile phone is not valid. Should be 10 digits with no other characters.");
    revert();
  }

  //validate pin 4 digits [0-9]{4}
  if (!validator.validatePin(pin)) {
    AnyException("Pin is not valid. Should be 4 digits.");
    revert();
  }

  if (!validator.validateAuthmanId(authmanId)) {
    revert();
  }

  bytes32 authmanIdHash = keccak256(authmanId);

  if (dao.getAuthmanAddressByAuthmanIdHash(authmanIdHash) != address(0)) {
    AnyException("Authman Id already in use. Try new authman Id.");
    revert();
  }

  address _address = dao.getAuthmanAddressByClaimHash(claimHash);

  if (_address == address(0)) {
    AnyException("Claim hash is not valid. No corresponding authman found.");
    revert();
  }

  if (dao.getIsClaimedByAddress(_address)) {
    AnyException("Authman is already claimed. Please unclaim first if it belongs to you.");
    revert();
  }

  bytes32 newClaimHash = createClaimHash(_address, pin);

  if (newClaimHash != claimHash) {
    AnyException("Pin is not valid.");
    revert();
  }    

  dao.claimAuthman(_address, authmanIdHash, mobilePhone);

}

}